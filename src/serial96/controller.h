/* $Id: controller.h,v 1.13 1998/10/13 03:05:23 dmdahle Exp $ */
/*************************************************************************
 *
 *controller.h
 *
 *This file contains the functions and data structures that make Kestrel's 
 *Controller.
 *
 *created 1/18/97 Justin Meyer justin@cse.ucsc.edu
 *
 *************************************************************************/

#ifndef _CONTROLLER_H_
#define _CONTROLLER_H_

typedef struct Controller
{
  /* internal registers */
  int pc;
  int pcstack[16];
  int pcstack_el;
  int cntrstack[16]; 
  int cntrstack_el;
  unsigned char Scratch;
  unsigned int cbs0 : 1, cbs1 : 1, cbs2 : 1,  cbs3 : 1, 
               cbs4 : 1, cbs5 : 1, cbs6 : 1,  cbs7 : 1;

  /* these values are generated by the controller and used by the
   * array to execute an instruction. These intermediate values are
   * used rather than having the array read and write directly
   * from the queues because the controller can select values for
   * data fields other than the queue. In particular, data flowing into
   * the array can come from QIn or the scratch register, and the values
   * written to Qout can come from the scratch register or the
   * wired-or bit shifter. Thus, the only way to put data output
   * from the array into QOut is through the scratch register.
   *
   * These directions are from the controller's perspective.
   */
  int ArrayDinMask;
  int ArrayDoutMask;
  unsigned char ArrayDataInLeft;
  unsigned char ArrayDataInRight;
  unsigned char ArrayDataOut;
  unsigned char ArrayImmediate;

  /* This is the data from the top of the QIn FIFO. we store it
   * here becuase it could go to two different places
   * in the controller (Array, Scratch) 
   */
  unsigned char qin_poped_data;

  /* set by Dec_Cntr when the current counter reaches zero and
   * the counter stack gets poped.  The flag is then checked by
   * Process_PC if the br_0 instruction bit is set to determine
   * whether or not to branch.
   */ 
  int poped_counter_stack;

  /* This bit gets set when an error condition occurs that causes 
   * instruction execution to stop. To clear this bit, the host
   * must be the controller in stop mode, and then restart execution
   * by going back to run mode. (Cleared in STOP CNTR_MODE_STOP case
   * in kestrel.c) 
   */
  int execution_halted;

  /* wired-or byte for board. Currently the board takes the wired
   * or pins from each Kestrel chips and runs them into the controller
   * to produce an 8-bit value that can be loaded into the CBS register
   * or used as a branch condition. */
  unsigned char wor;

  /* The branch of wired of operation from the third previous
   * instruction, so some pipelining is necessary */
  unsigned char wor2, wor3;

  int state;

} Controller;


/* These defines are the major control bits of the controller
 * command register. They tell the controller what sort
 * of operation we want to perform (see board schematic) */
#define CNTRBIT_LOAD_TOGGLE 	0x0001
#define CNTRBIT_RUN     	0x0002
#define CNTRBIT_SINGLE		0x0004
#define CNTRBIT_DIAG  		0x0008

/* !!! the following 7 bits control output enables of chips in the
 * kestrel array.  It is possible to create drive fights on the board
 * which can damage the hardware, so don't mess with these unless tou
 * are very familiar with the board design!!!
 */

/* output enable of banks of kestrel PEs 
 * for prototypes 1=disabled, 0=enabled
 * for 64 PE chipds, 1=enables, 0=both outputs on due to a hardware
 * bug never set any of these bits to 0 with 64 PE chips in the board
 * because it creates a drive fight that could damage our very
 * expensive chips.  
 */
#define CNTRBIT_K0_ENABLE	0x0010
#define CNTRBIT_K1_ENABLE	0x0020
#define CNTRBIT_K23_ENABLE	0x0040
#define CNTRBIT_K4567_ENABLE	0x0080

/* output enable of bypass buffer (1=disables, 0=enables */
#define CNTRBIT_BUF0_ENABLE	0x0100
#define CNTRBIT_BUF1_ENABLE	0x0200
#define CNTRBIT_BUF2_ENABLE	0x0400

/* a 0->1 transition on this bit causes the controller to pop * the
 * input queue. */
#define CNTRBIT_QIN_LOAD 	0x0800

/* these three commands are currently unused */
#define CNTRBIT_COMMAND_2	0x1000
#define CNTRBIT_COMMAND_3	0x2000
#define CNTRBIT_COMMAND_4	0x4000

/* Reset the FPGA (0=reset mode, 1=normal mode) */
#define CNTRBIT_FPGA_RESET	0x8000

/* this mask is always or'd with the command register when written */
#define CNTRBIT_BOARD_ENABLE_MASK	(CNTRBIT_FPGA_RESET|CNTRBIT_BUF0_ENABLE|CNTRBIT_BUF1_ENABLE|CNTRBIT_BUF2_ENABLE)

/* The state of CNTRBIT_LOAD_TOGGLE is unimportant, it only
 * causes activity if changed in SINGLE, LOAD_INS, READ_INS,  and
 * PROG_FIFO modes to indicate to the controller that the 
 * operation configured by the host (us) should be performed.
 * (that is, the controller only detects changes in this bit)
 * 
 * These state are defined definitely in the controller schematics.
 */
#define CNTR_MODE_STOP 		0x0000
#define CNTR_MODE_RUN		CNTRBIT_RUN
#define CNTR_MODE_SINGLE	CNTRBIT_SINGLE
#define CNTR_MODE_LOAD_INS	(CNTRBIT_SINGLE|CNTRBIT_RUN)
#define CNTR_MODE_READ_INS	(CNTRBIT_SINGLE|CNTRBIT_DIAG)
#define CNTR_MODE_PROG_FIFO	(CNTRBIT_RUN|CNTRBIT_SINGLE|CNTRBIT_DIAG)
#define CNTR_MODE_DIAG		CNTRBIT_DIAG

#define CNTR_MODE_TERMINATE	(CNTRBIT_BOARD_ENABLE_MASK & ~(CNTRBIT_FPGA_RESET))

/* values for d_out that select the diagnostic mode ouput */
#define DIAG_MUX_CBS 0
#define DIAG_MUX_SCR 1
#define DIAG_MUX_CTR 2
#define DIAG_MUX_PCSTACK 3
#define DIAG_MUX_CTRTOS_LO 4
#define DIAG_MUX_CTRTOS_HI 5
#define DIAG_MUX_PC_LO 6
#define DIAG_MUX_PC_HI 7

/* controller immediate selection field */
#define IMM_MUX_CTRTOS_LO 0
#define IMM_MUX_SCR 1
#define IMM_MUX_QIN 2
#define IMM_MUX_ZERO 3

/* scratch register MUX selects */
#define SCR_MUX_DATA 0
#define SCR_MUX_UNUSED 1
#define SCR_MUX_QIN 2
#define SCR_MUX_CBS 3

extern Controller controller;

void Init_Controller(void);
void Load_CBS(void);
void Shift_CBS(void);
int Push_PC(void);
int Pop_PC(void);
int Push_Cntr(void);
int Pop_Cntr(void);
int Dec_Cntr(void);
void Process_PC(void);
void Process_Cntr(void);
void Process_Cont_Output(void);
void Process_CBS(void);
void Pre_Process_Scratch(void);
void Process_Scratch(void);
void ComputeDiagnosticOutput(void);
void Pre_Controller_Execute(void);
void Post_Controller_Execute(void);
int Execute_Instruction(int state_was_stop, int state);

#endif




